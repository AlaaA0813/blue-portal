
data model methods: a means by which you can implement protocols.

# some behavior that I want to implement -> write some __function__
# top level function or top level syntax -> __corresponding__
# x + y -> __add__
# init x -> __init__
# repr(x) -> repr
# x() -> __call__

class Polynomial:
	def __init__(self, *coeffs):
		self.coeffs = coeffs

	def __repr__(self):
		return 'Polynomial(*{!r})'.format(self.coeffs)

	# Lets add them together....
	def __add__(self, other):
		return 'Polynomial(*(x + y for x, y in zip(self.coeffs, other.coeffs)))

	# len(p1) provides the size of an object.
	def __len__(self):
		return len(self.coeff)

	def __call__(self):
		pass

p1 = Polynomial(1, 2, 3) # x^2 + 2x + 3
p2 = Polynomial(3, 4, 5) # 3x^2 + 4x + 3


oop - patterns to look out for as you learn python
-quarter view view.
-built-in inheritance.
-how oop works.

-----------------------------------------------------------------------------------

meta classes: constraints can be enforced on the user end of code to ensure it runs correctly or exists

if you understand what the feature is about, it is very clear as to why you use it.

if a person who writes a library method removes a function that you use, write a test to see if that function exists or runs.  

enforce a constraint on a user level and a library level.

python has a notion of hooks and safety valves within it.  a language for protocols.

python code runs top to bottom and linearly.

user code: the derived class is saying the base class has to have these characteristics in order for me to run and be happy.  otherwise i will fail loudly.

library code: write a check to see if a method/function is defined.
theres a function in python called. __build_class__.
what are **kw arguments?

meta classes are classes that derive from type that has some special methods on them.  must read the documentation to really understand.  they fundamentally allow you to intercept the construction of derived types.

raise instead or return?

find a way to intercept how classes are constructed:
- __build_class__
- meta classes
def __init__subclass__(self, *a, **kw):
	print('init_sublcass', a, kw)
	return super().__init_subclass__(*a, **kw)

-----------------------------------------------------------------------------------

decorators: syntax that wraps functions with a certain behavior so code does not have to be rewritten.  allows you to wrap lots of functions with certain behaviors without having to rewrite code.

begins with @
then directly followed by function

python interpreter will tell you when and where a function in a module is.
	python -i <filename>

inspect module can tell you what your source code is
	can as what file certain code was defined on, what line too

you dont need upfront design to write your code like C++.  if things go wrong you wont have to completely rewrite your code.  it is a live language with a runtime representation.

define functions with runtime.
wrapping functions with behaviors.